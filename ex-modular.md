## exModular 2023-09

### Модернизация системы 2023-09:

Refactor:

1) при описании модуля - добавить функции-фабрики в массив Models. В описание модели добавить seedFileName - если 
такое поле есть, то на этапе инициализации будет загружены начальные данные; Также добавить поле seeds в описание 
модуля - там будет массив объектов формата `{ modelName: string, seedFileName: string }`, этот массив будет также 
использован на этапе инициализации;

2) изменена система инициализации приложения: 
   * функция appBuilder создает приложение (внутри вызываем функцию exModular для инициализации части специфических свойств)
   * далее инициализируем пользовательские модули
   * далее appInit инициализирует приложение
   * далее (при необходимости) serverBuilder делает из приложения сервер и запускает его
   
Для добавления новых моделей в систему:


## appBuilder 2.0 (exModular)

collection of services:

* `.services`: мета-сервис для перечисления всех зарегистрированных сервисов в системе (например, для визуализации)
* `.storage`: сервис хранения
* `.models` - глобальное пространство имён моделей
* `.access`: сервис контроля доступа
* `.controller`: сервис генерации кода контроллеров
* `.serial`: вспомогательный сервис для создания последовательности асинхронных операций (промисов)
* `.routeBuilder`: сервис генерации маршрутов в формате MW для express
* `.appBuilder`: мета-сервис генерации приложения по конфигурации, заполняет справочник `services`
* `.serverBuilder`: сервис генерации сервера express из текущего приложения
* `.message`: сервис уведомления о событиях, произошедших в системе

### Сервис `codegen`

Сервис предназначен для генерации кода клиентского приложения на основе декларативного описания приложения с сервера.

Роуты:

* `/codegen/model/:modelName`
* `/codegen/model/:modelName/list`
* `/codegen/model/:modelName/edit`
* `/codegen/app/resources`: генерация списка ресурсов для файла `app.js`. Как строка запроса можно передать массив из имен моделей, для которых нужно сгенерировать код примерно так: `?models=MrpPlan&models=MrpProduct`
* `/codegen/app/imports`: генерация списка импортов компонентов и иконок ресурсов для 'app.js'. Строковым параметром опционально передается список моделей (если нет параметра - генерируется для всех моделей) 

### Сервис appBuilder:

Загрузить конфигурацию, инициализировать список сервисов.

### Сервис `.storage`

Схема (schema): система описания структуры данных в системе, содержит в себе схему объектов, правила их инициализации 
и валидации. Также может содержать дополнительные обработчики событий - на языке flow.

Драйвер (driver): на основании схемы создает подключение, инициализируя его;

Подключение (connection): содержит инициализированную схему данных в виде объектов доступа - моделей.


Сервис хранения информации в системе. Работает через подключения.

Модель: это описание схемы объекта.
Для каждой модели можно создать объект для доступа к данным в хранилище. 

  * `.storage.drivers`: драйвера для системы хранения
  * `.storage.core`: системное хранилище для моделей системы и других сервисов;
  * `.storage[connectionName`: подключение к хранилищу, содержит описание подключения;
  * `.storage[connectionName].models` - модели, которые существует в указанном подключении к хранилищу

Подключение (connection): 
  * 

Драйвера:
  * knex-sqlite: полнофункциональный драйвер для хранения информации локально в базе SQLite
  * knex-mssql: полнофункциональный драйвер для хранения в базе MSSQL Server
  * json-driver: драйвер для чтения локальных ресурсов
    * представить данные services через этот драйвер; на клиенте визуализировать через CardTableView;
  
Json драйвер работает так: создается модель внутри 


### Сервис 'routeBuilder'

Используется для создания роутов в express.

Свойства модели:
* beforeCreateBeg, beforeCreateEnd, `.afterCreateBeg`, `.afterCreateEnd` - позволяют добавить в дополнение к 
стандартным обработчикам свои кастомные (например, обрабатывают пользовательский код). В данном случае на событие 
`Create`;


### Сервис `.message`

* `.message.mail`: драйвер для сервиса уведомлений через электронную почту
  * `.message.mail.drivers`: список драйверов для различных сервисов электронной почты
  * `.message.mail.system`: подключение для оптавки системных уведомлений
  * `.message.mail[connectionName]`: остальные подключения к различным email сервисам

Сервис предназначен для управления уведомлениями о событиях, произошедших на сервере. Сервис использует систему 
контактных данных `.contact` о получателях уведомлений. В системе регистрируется контакты администратора, разработчика 
и текущего пользователя. Также могут существовать различные иные контакты.

Система нотификации может быть расширена через пользовательские скрипты перед нотификацией или после нотификации.

Драйвера для системы сообщений:
* server log
* server console
* http webhook
* sms
* telegram
* email

В системе указывается перечень системных получателей сообщений:
* dev: сообщения о ходе работы процедур и прочее - используется при отладке и тестировании, настраивается по каждому
  модулю
* admin: сообщения о работе сервера разных уровней - уведомления, ошибки и тп;
* userContacts: текущий авторизованный пользователь; этот получатель фиксируется каждый раз при работе системы авторизации;
* можно указать произвольный массив контактов, чтобы система нотификации уведомила нужного пользователя;


Работа сервиса может быть настроена в зависимости от режима работы сервера - разработка, тестирование или продакшн.

На этапе разработки/тестирования выводятся отладочные сообщения по тем блокам/модулям, которые в настоящее время 
отлаживаются (зависит от конфигурации).


Также в ходе работы приложения могут отправляться транзакционные уведомления - в зависимости от настроек пользователя. 
Пример транзакционных уведомлений - функция сброса пароля или о необходимости подтвердить аккаунт пользователя.




# ExModular project

ExModular is Express-based app toolkit with features:

* declarative module system for models, routes, controllers
* user, userGroup 
* password auth
* JWT tokens
* sessions
* route permissions: individual user or userGroups
* storage (knex-based) with some ORM for typed access to data objects
* app init with seeding system and sample data 

## Declarative module system

Declaratively define models, routes, controllers.

## appBuilder.services

Services API:

* controller
* errors
* mailer
* codegen
* serial
* validator
* wrap


## Storage-knex

### findAll(opt)

opt:
* where: `object`: k-v pairs of field / value
* whereOp: `array`: [{ column, op, value }]
* whereIn: `array`: [{ column, ids }]
* orderBy: `array`: [{ column, order: 'asc/desc' }]

## Access-Simple

Модуль для регистрации простого доступа в системе

API:

* registerLoggedUser (user): зарегистрировать вошедшего в систему пользователя
* unregisterLoggedUser (user): зарегистрировать выход пользователя из системы
* addAdmin(user): добавить пользователя к группе администраторов

## Auth-JWT

Модуль для авторизации посредством JWT

Auth-JWT API:

* encode (sessionId): закодировать идентификатор сессии в JWT, вернуть JWT  
* getTokenFromReq (req): получить из заголовка авторизации структуру { scheme: , token: } 
* check (req, res, next): миддлваре для проверки авторизации - получить токен из запроса, декодировать и проверить его, поместить в req.user.jwt, загрузить сессию в req.user.session, загрузить профиль пользователя в req.user. При ошибке продолжить с ошибкой ServerNotAllowed. 

## Auth-password

Модуль для входа в систему посредством логина и пароля

Auth-password API:

* module.login(req, res): контроллер для роута входа в систему.
* module.logout(req, res): контроллер для маршрута выхода их системы
* module.routes: определенные маршруты (/auth/login, auth/logout)

## Model definition

Модели в системе описываются декларативным путем.

Model.key - содержит название поля-идентификатора записи
Model.props -  массив, содержит описание полей в следующем формате:

* name:
* type:
* format:
* default:
* caption:
* beforeSave: 
* getter
* calculated

Model.resourcePath: на какой маршрут монтировать 
 
Типы свойств (prop type):
* `array`: `.itemType` указывает тип элементов - поддерживается только `(decimal, id)`
* `refs`: массив ссылок на элементы, нужно ещё указать `.model` - на какую модель ссылаемся
* `ref`: ссылка на элемент в другой модели `.model`
* `decimal`: `.precision` знаков всего и `.scale` знаков после запятой
* `text`: строка текста, размер можно задать свойством `.size`, формат задаётся свойством `.format` (string, date, email, name, ...)
* `datetime`: дата / время. Формат текстового представления задает свойство `.format` - по умолчанию это `DD-MM-YYYY`

## Filter

Filter types:
* special q filter
* simple values: json object
* conditional filter: json object with suffixes for keys _lt, _lte, _gt, _gte

/route?filter=q:some%20text
/route?filter={someprop: somvalue}
/route?filter={someprop_gte: somevalue, someOtherProp_lt: otherValue}

## Flow

flow - потоки выполнения, набор команд, которые может выполнить система. Некий аналог скрипта. Состоит из отдельных шагов.

statement (st) - отдельный шаг в потоке выполнения. Аналогичен строке кода в скрипте. Шаг может быть разных типов - или действие (action), или условным (if).

action -  действие. Аналог вызова функции в скриптовых языках. Для работы с параметрами вызова, передаче результата, использования глобальных переменных используются контексты.

ctx - контекст. Контекст бывает глобальный (общий для всего потока действий), и контекст действия. Контекст действия готовится для каждого st отдельно.  

API сервиса flow монтируются на appBuilder.flow:

* `flows`: `{Object}` : потоки выполнения в системе, записаны под своими именами, имя - ключ в этом объекте
* `add(name, flow)`: `fn` : добавить указанный flow под именем name в объект flows
* `actions`: `[Array]` : массив действий, определенных в системе.
* `processAllActions()`: `fn` : метод инициализирует все действия, создает у них обязательные переменные input, output и производит импорт моделей (.models) и сервисов (.services), которые использует данное действие. На момент вызова действия гарантируется, что импорт выполнен.
* `run(flowName, flowCtx)`: `fn` : метод для запуска действия по имени. Можно передать начальный контекст. Возвращает Promise с контекстом на момент завершения выполнения потока действий.
* `prepareActionCtx(action, stCtx)`: `fn` : метод для подготовки контекста действия
* `runSt(flow, ctx)`: `fn` : выполнить шаг из потока. Номер шага должен быть указан в `ctx.flow.ndx`

Cтандартные действия (actions):

* `checkDomain`:
  * input: `email` : указываем email, который нужно проверить на принадлежность к определенным доменам
  * env.AUTH_SIGNUP_CHECK_DOMAIN : если такая переменная установлена в false, проверка не производится. Если в true, то регистрацию пройдут только пользователи, чьи домены перечислены в ресурсе UserDomain, и для ниж установлено свойство UserDomain.isAllow в true

